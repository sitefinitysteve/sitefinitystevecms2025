{
  "publishedAt": "2012-03-16T01:53:19.1770000Z",
  "legacyUrl": "/code/2012/03/16/compiling-controls-against-multiple-sitefinity-versions",
  "needsFixing": false,
  "slug": "compiling-controls-against-multiple-sitefinity-versions",
  "featuredImage": "/images/stock/500x280/img2.jpg",
  "markdown": true,
  "title": "Compiling Projects against multiple versions",
  "tags": [
    "Tutorial",
    "Sitefinity"
  ],
  "content": "Creating innovative software is a lot of fun. Usually this is the equation for coming up with some pretty useful plugins, modules, and applications. Sometimes they are so useful that I distribute them to communities to use for their own projects. This way, I feel as if I am contributing to the evolution of technology and even humanity :)\n\nThere are some tedious tasks involved when doing this that slow down my development, which is not so fun. If you develop solutions targeted for multiple versions of a software, you will be sure to get this error back from the community:\n\n```\nCould not load file or assembly 'MyAssembly.Sub,\nVersion=3.7.2096.3, Culture=neutral,\nPublicKeyToken=dfeaee3f6978ac79' or one of its\ndependencies. The located assembly's\nmanifest definition does not match the assembly\nreference.\n(Exception from HRESULT: 0x80131040)\n```\n\n## DLL Hell\nA term coined over a decade ago still applies even today. The problem is that the project was compiled referencing a specific version of a software, then someone tries to load your plugin into a software under a different version.\n\n## Juggaling Multiple Versions\nEven though you are providing one solution, you are forced to maintain multiple projects, each referencing a version of the software you are targeting. What if your code is identical for all software versions? This means you will have to keep the folders and files synchronized with every update you do. This is where it becomes tedious since you have to duplicate your projects for each software version and reference the respective DLL's for that version. What a waste of space, time, and energy! So how can you easily share code and write reusable components for all versions of the software?\n\n## Welcome to Project Linker!\nThere is a little known tool called Project Linker that lets you create a link to another project. The reason why it is not commonly known is because it is mainly used in Silverlight and WPF development due to a complication that exists in that combination, but the concept can be used in any development.\n\nYou may already know that you can create a link to another file so you can maintain just one code file. However, the beauty of linking on a project level is that it will automatically create and maintain links from a source project to a target project for sharing code that is common between your target versions. Therefore, shared code can be written once and built for the target environment. The trick is that each project manages its own references, resources, and code specific to the target software version. What a relief!\n\n## Installing Project Linker for Visual Studio 2010\nThe following procedures describe how to install the Project Linker:\n\nGo to Extension Manager in VS 2010\nSearch for Project Linker\nInstall Project Linker extension\nThat's it!\nThe Project Linker is available as a Visual Studio extension\n\n## Project Linker Usage\nTo link a source project to a target project, right-click the target project, and then click Add Project Link. In the Select Project dialog box, click the source project, and then click OK. The Select Project dialog box is shown in below:\n\nProject Linker Dialog\n\nOnce the projects are linked together, a file added to the source project will create a link to the original file in the target solution. Same goes for folders too.\n\nLinked Projects: In this case, 'SilverlightApplication1' is the source project where you create and maintain your code. Once a file or folder is created, the same is automatically created in the 'WpfApplication1' project!\n\n## Tips for Project Linking\nBelow are some things to keep in mind when linking projects:\n\nUse the least common denominator as your source project.\nIf you are linking existing projects, you can trigger the initial linking synchronization by selecting all folders contained in the source files and click on \"Exclude from project\" in context menu. Then after enabling \"Show all files\" options and include them back, the Project Linker will kick in and will link all added source files to the Target Project.\nKeep the namespaces in the project properties the same for the two linked projects. This way, your code can remain identical.\nUse the Conditional compilation symbols in the project properties if you want to apply specific code based on the version you are trying to target. This makes using #if COMMUNITY #Else #Endif conditional statements possible.\nI hope this helps you manage your code easier when multi-targeting software. Although you may have several projects in your solution, now all you have to focus on is your code!\n\nENJOY!!\n\n## What Next? Facade Pattern!\nYou may already be fortunate enough if your software vendor provides a facade pattern design. With the facade pattern, you can develop version-agnostic code that does not depend directly against a versioned DLL. This would mean you do not need multiple projects to support different versions! It is a very elegant way to handle this problem. Check out Sitefinity 4's API to see how they handle this for their community.\n\n--Credit: [https://www.basememara.com](https://www.basememara.com)\n",
  "seoMetaImage": "/images/stock/500x280/img2.jpg",
  "seoDescription": "How to build once and end up with multiple assemblies target at many sitefinity versions"
}